# 운영체제

### 운영체제란?
- 운영체제란 컴퓨터 하드웨어 바로위에 설치되어 하드웨어를 직접 관리하고 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 컴퓨터의 주요 소프트웨어이다.

### 운영체제의 처리 방식?
- 운영체제의 처리방식은 크게 일괄 처리, 시분할처리, 실시간처리, 분산처리, 다중처리등이 있다.
- **일괄 처리란** 여러 작업을 한번에 처리하는 방식으로 해당 작업이 끝날때 까지 다른 작업을 진행할 수 없다.
- **시분할 처리란** 현대 범용 운영체제에서 사용하는 처리방식으로 시간단위로 분할하여 작업을 처리하는 방식이다. CPU의 빠른속도로 인해 인간은 시분할처리를 하더라도 동시에 작업이 수행된다고느낄 수 있기때문에 범용 운영체제에서 주로 사용한다.
- **실시간 처리란** 정해진 시간내에 반드시 결과가 나와야하는 처리 방식이다. 주로 의료용, 군사기기등 한치의 오차도 허용할 수 없는 곳에서 사용하는 방식이다.
- **분산 처리란** 하나의 컴퓨터에서 수행하던 작업을 네트워크를 통해 여러 컴퓨터로 분산하여 처리하는 방식이다.
- **다중 처리란** 하나의 컴퓨터에 여러개의 CPU를 두어 병렬로 처리하는 방식이다.

### 커널?
- 커널은 운영체제의 핵심 부분으로 메모리에 상주되어 시스템을 통제하는 소프트웨어

### 레지스터?
- CPU에게 필요한 데이터를 일시적으로 가지고 있는 매우 빠른 기억장치

### 프로그램 카운터?
- 프로그램 카운터는 다음번에 실행할 명령어의 주소를 가지고 있는 레지스터

### 메모리 공간을 나누는 이유?
- 유사향 성향의 데이터를 공간을 나누어서 저장하면, 관리가 용이해지고 메모리 접근 시간을 줄일 수 있어 효율적으로 메모리를 사용할 수 있다.


### 운영체제에게 제어권을 넘기는 방법

#### 1) 강제로 넘겨지는 것
- 매순간 기계어를 읽어 실행하는 CPU는 사용자에게 제어권이 넘어가면 운영체제는 해당 CPU를 제어할 수 없다.
- CPU는 매우 중요한 컴퓨터 자원이기 때문에 사용자가 CPU의 제어권을 가지고 내어놓지 않거나, 해당 CPU를 마음대로 조작하여 시스템을 공격하는 것을 방지하기위해 모드비트와 타이머가 있다.
- **모드비트란** 사용자가 CPU의 제어권을 가지고 있을 때는 1, 운영체제 커널이 제어권을 가지고 있을때는 0이다.
- 모드비트가 1일때 특권명령(시스템에 중요한 명령)을 수행하게 되면 강제로 제어권이 운영체제로 넘어가게 된다.
- **타이머란** 사용자가 CPU의 제어권을 타이머에서 정한 시간까지 내어놓지 않으면 자동으로 제어권이 넘어가게 하는 기능이다.
- 이외에도 I/O작업이 끝나 **인터럽트가 발생하면** 해당 작업을 처리하기 위해 제어권이 넘어가게 된다.

#### 2) 스스로 내어놓는 것
- I/O 요청과 같이 운영체제만 할 수 있는 특권명령의 경우 사용자는 스스로 **시스템 콜을** 통해 제어권을 운영체제게 넘겨 해당 작업을 수행하도록 한다.

### DMA(Direct Memory Access)?
- I/O의 잦은 인터럽트는 오버헤드의 원인중 하나이므로 자원을 효율적으로 사용하기 위해 I/O요청이 끝난 후 인터럽트를 통해 운영체제가 메모리에 올리는 것이 아닌 디바이스 컨트롤러가 직접 메모리에 작업을 올릴 수 있는 방법.

### 프로세스와 쓰레드?
- 프로세스란 메모리에 올라가 실행중인 프로그램이며 쓰레드는 프로세스 중 CPU의 수행단위를 별도로 가지고 있는 것
- 쓰레드는 프로세스의 코드, 데이터, 힙 영역을 공유하고있으며 각각 스택과 프로그램 카운터영역을 별도로 가지고 있다.
- 쓰레드를 사용하면 프로세스 자원을 공유할 수 있으므로 **자원을 효율적으로 사용** 할 수 있으며, 보통 프로세스 하나를 만드는 것보다 쓰레드를 하나 만드는게 훨씬 자원을 적게 소모하므로 **경제적이고**, 상황에 따라 쓰레드를 병렬로 구성하면 **빠르게 자원을 처리** 할 수 있는 장점이 있다.

### 멀티 프로세스와 멀티 쓰레드의 장단점?
- 멀티 프로세스의 장점은 하나의 프로세스에서 문제가 발생하더라도 다른 프로세스에게는 영향을 주지않는다는 것이다.
- 멀티 프로세스의 단점은 쓰레드보다 자원을 더 많이 소모하며 context switching overhead가 심하다.
- 멀티 쓰레드의 하나의 프로세스내에서 필요한 자원을 공유하므로 자원을 효율적으로 사용할 수 있고 쓰레드간 스위칭은 프로세스간 스위칭하는것보다 overhead가 적다.
- 하지만 멀티 쓰레드는 자원을 공유하기때문에 동기화 문제가 발생하기 쉽고 쓰레드의 문제가 발생하면 다른 모든 쓰레드에게 영향을 줄수도 있다.

### 커널 쓰레드와 사용자 쓰레드에 대해 아시나요?
- **커널 쓰레드는** 운영체제가 알고 있는 쓰레드로 커널이 쓰레드들을 제어할 수 있다.
- 각 프로세스는 적어도 1개 이상의 커널 쓰레드를 가지고 있다.
- **사용자 쓰레드는** 운영체제가 알지 못하며 운영체제는 한개의 프로세스로 인식하고 CPU를 해당 프로세스에게 할당해주고 해당 프로세스에서 각 쓰레드들을 제어한다.
- 예를들어 운영체제는 JVM을 하나의 프로세스로 인식하고 CPU를 할당해주고 JVM이 각 쓰레드들을 관리한다.

### 프로세스의 구조에 대해 아시나요?
- 프로세스의 주소 공간은 코드, 데이터, 스택, 힙 영역으로 나누어져 있다.
- **코드영역에는** 프로세스가 실행한 기계어 코드가 있으며 오직 읽기만 가능한 영역이다.
- **데이터영역은** static, 전역 변수와 같은 데이터들이 저장된다.
- **스택영역은** 함수나, 지역변수들이 저장되어 있고 힙 영역에는 프로그램 실행도중 동적으로 사용할 데이터들이 저장된다.

### Context Switching(문맥 교환)?
- CPU가 프로세스에서 다른 프로세스로 넘어가는 과정이다.
- 보통 시스템 콜을 통해 CPU의 제어권을 넘겨주거나, 인터럽트, 타이머 초과등으로 인해 제어권을 뺏기는 과정을 문맥교환이라고 할 수 있다.

### 프로세스 상태?
- 프로세스 상태는 Ready, Running, Blocked로 구성된다.
- **Running** 상태는 해당 프로세스가 CPU에 올라가 작업을 수행하고 있는 상태이다.
- **Ready** 상태는 CPU를 사용할 다른 모든 조건들을 만족하고 있어 CPU만 받으면 되는 상태이다.
- **Blocked** 상태는 I/O작업과 같은 다른 작업이 수행되고 있어 CPU를 주어도 해당 작업을 수행할 수 없는 상태이다.

### 프로세스 큐?
- 프로세스 큐는 프로세스의 집합으로 잡큐, 레디큐, 디바이스 큐로 구성되어 있다.
- **잡 큐에는** 현재 시스템 내의 모든 프로세스가 들어가 있다.
- **레디 큐에는** 레디 상태인 프로세스가 들어가 있다.
- **디바이스 큐에는** Blocked상태이며 I/O 디바이스 처리를 기다리는 프로세스들이 들어가 있다.

### 프로세스 스케줄링에 대해 아시나요?
- 프로세스 스케줄러는 장기, 중기, 단기 스케줄러가 있다.
- **장기 스케줄러는** 시작 프로세스 중 몇개를 메모리에 올릴지 개수를 정해놓은 방식으로 스케줄링 하는것이다. 시분할 시스템에서는 장기 스케줄러를 사용하지않고 주로 중기 스케줄러를 통해 프로세스를 스케줄링한다.
- **중기 스케줄러는** 여유 공간을 마련하기위해 프로세스를 메모리에서 디스크로 쫒아내 suspended 상태로 만들어 프로세스를 스케줄링 한다.
- **단기 스케줄러는** CPU를 누구에게 줄지 결정하는 CPU 스케줄러이다.

### 프로세스의 4가지 시스템콜?
- **부모 프로세스가 자식 프로세스를 만들 때** 프로세스는 직접 만들 수 없으며 **fork() 시스템 콜을** 통해 운영체에게 프로세스를 만들어 달라고 요청을 하며 자식 프로세스는 부모 프로세스를 카피한 형태가 된다.
- 이렇게 만들어진 자식 프로세스에게 새로운 프로그램을 덮어 올리는 **exec() 시스템콜을** 통해 **새로운 프로그램을 할당** 한다.
- 그리고 **자식 프로세스가 종료될때 까지 기다리는** **wait() 시스템콜이** 존재한다. 흔히 리눅스에서 vim으로 문서를 작성할 때 wait() 시스템콜이 호출되어 부모 프로세스는 blocked되고 vim 파일이 종료되는 것을 생각하면 된다.
- 마지막으로 **현재 프로세스를 종료하고 자원을 반납하는 exit() 시스템콜이** 있다.

### 프로세스간 협력 매커니즘(IPC)?
- 보통 프로세스는 독립적으로 동작하므로 하나의 프로세스가 다른 프로세스를 실행할 수 없지만 프로세스간 협력 매커니즘을 통해 하나의 프로세스가 다른 프로세스에게 영향을 줄 수 있는 프로세스간 협력을 할 수 있게 해준다.
- **메시지를 전달하는 방식과 주소 공간을 공유하는 방식으로** 협력이 가능하다.
- **메시지를 전달하는 방식은** 운영체제가 매개가되어 전송 프로세스는 시스템콜로 운영체제에게 메시지를 전달하고, 운영체제가 수신 프로세스에게 해당 메시지를 전달하는 방식이다.
- **주소를 공유하는 방식도** 프로세스가 운영체제에게 요청을 하여 메모리 주소를 공유할 수 있게 된다.

### CPU 스케줄러?
- Ready 태의 프로세스 중 누구에게 CPU를 줄지 결정하는 스케줄러.

### 프로세스가 비선점, 선점이 되는 경우?
- 프로세스가 I/O요청을 처리하기 위해서 시스템 콜을 통해 Running 상태에서 Blocked 상태로 가는 경우와 프로세스의 작업이 종료되어 CPU에게 제어권이 넘어가는 경우는 **스스로 자원을 반납하므로 비선점(non preemptive)**
- Running상태에서 타이머나 인터럽트로 인해 제어권을 뺏기는 경우에는 **해당 제어권을 강제로 빼았는것이므로 선점(preemptive)**

### CPU 스케줄링의 성능 척도?
- CPU 스케줄링은 이용률, 처리량, 소요시간, 응답시간, 대기시간으로 성능 척도를 계산한다.
- **이용률은** CPU가 얼마나 일을했는지에 대한 척도이다.
- **처리량은** 단위 시간당 처리한 프로세스이다.
- **소요시간은** 프로세스가 CPU를 기다린시간과 사용한 시간을 합친 것이다.
- **응답시간은** 프로세스가 대기 상태일때 **처음으로 CPU를 얻을때 까지 걸린 시간이다.**
- **대기시간은** CPU를 기다린 전체 시간이다.



### CPU 스케줄링 알고리즘에 대해 설명해주세요.
- CPU 스케줄링 알고리즘은 **First-Come First-Served, Shortest-Job-First, Priority Scheduling, RoundRobin, Multilevel Queue, Multilevel Feedback Queue등이 있다.**
- **First-Come First-Served 알고리즘은** 먼저 들어온 프로세스 부터 처리하는 방식으로 이 방식은 처리 시간이 긴 프로세스부터 들어온다면 대기 시간이 매우 길어지는 단점이 존재한다.
- **Shortest-Job-First는** 처리시간 짧은 프로세스 부터 처리하는 방식으로 대기 시간 측면에서는 가장 짧은 지연을 가지지만 Starvation(기아 현상)문제가 발생할 수 있다.
- **Priority Scheduling은** 우선순위가 높은 프로세스부터 처리하는 방식으로 Shortest-Job-First가 이에 해당될 수 있다. Starvation 문제는 오래 기다린 프로세스에게 높은 우선순위를 줄 수 있는 에이징 기법을 사용하여 해결한다.
- **RoundRobin은** 현대 범용 운영체제에서 CPU 스케줄링의 근간이 되는 방법이다. 각 프로세스는 **동일한 크기의 할당 시간을 가지고** 할당 시간이 지나면 프로세스는 선점당해 다시 **레디 큐에 들어가 줄을 서게 된다.** 그러므로 프로세스들은 자신의 수행시간에 따라 대시간이 결정되므로 합리적이라고 할 수 있다.
- 하지만 라운드 로빈에서 **할당 시간을 매우 크게 잡으면** First-Come First-Served와 다를게 없어지고 **할당 시간을 너무 작게 잡으면** 컨텍스트 스위칭 오버헤드가 커질것이다.
- 그러므로 할당시간을 적절하게 결정해야하는데 **보통 I/O작업은 한번에 처리할 수있을 정도의 할당시간을 정한다.**
- 그리고 RoundRobin은 프로세스들의 수행시간이 다양할 때 유리한 방법이지 모든 프로세스의 수행시간이 동일하다면 효율적이지 않다.
- **멀티레벨 큐는** 레디 큐를 여러개로 분할하고 각 큐는 독립적인 스케줄링 알고리즘을 통해 스케줄링하는 방식이다. 흔히 백그라운드에 배치 잡(FCFS), 포어그라운드에는 인터랙티브하는 잡(RoundRobin)을 배치하여 각각 알맞는 스케줄링 알고리즘을 사용한다.

### 동기화
- 여러 프로세스나, 쓰레드가 하나의 공유자원에 접근하는 것

### 프로세스, 쓰레드 동기화 문제?
- 공유 데이터에 동시에 접근하여 데이터의 불일치가 발생하는 것

### Critical Section(임계 구역)?
- Ciritical Section이란 공유 자원에 접근하는 코드 영역이다.
- Critical Section에서 발생하는 동기화 문제를 해결하기 위해서는 **Mutual Exclution, Progress, BoundedWaiting을 만족해야한다.**
- **Mutual Exclution(상호 배제)이란** 하나의 프로세스만이 그 자원을 이용할 수 있는 것이다.
- **Progress(진행)는** 아무도 임계영역에 있지 않을때는 들어가고자 하는 프로세스를 들어가게 해주어야 한다.
- **BoundedWaiting(유한대기)이란** 특정 프로세스가 해당 자원을 사용하려고하는데 기아 현상이 발생하면 안된다는 것이다.

### 동기화 기법?
- 동기화 기법은 대표적으로 **세마포어, 모니터 기법이 있다.**
- 이러한 기법이 없었을 때에는 동기화 문제를 해결하기위해 lock이라는 이진 변수를 공유하면서 Critical Section에 들어갈 때 락을 걸고 Critical Section을 빠져나올때 락을 푸는 방식으로 동기화 문제를 해결하였다.
- 그 후에 조금 더 간편하게 동기화 문제를 해결해줄 수 있는 세마포어가 생겨났다.
- **세마포어는 변수값을 통해 자원의 개수를 관리하고, 자원할당(P(S)), 자원 반환(V(S))이라는 연산을 제공해 동기화를 해결할 수 있는 추상자료형이다.**
- 흔히 자원을 하나만 가지는 이진세마포어를 **뮤텍스라고 부른다.**
- 세마포어는 Block-Wakeup, Busy-Wating 방식으로 동기화 작업을 수행할 수 있다.
- **Block-Wakeup방식은** 프로세스가 공유 자원을 사용하려고 할 때 사용할 자원이 존재하지않으면 CPU를 반납하고 Block 상태로 만들고 다른 프로세스가 해당 자원을 반환할 때 **Block된 프로세스를 깨워주는 방식이다.**
- 하지만 세마포어도 데드락문제가 발생할 수 있으며 **프로그래머가 직접 세마포어를 사용하여 동기화문제를 해결해야하므로 실수가 발생할 여지가 있다.**
- 그러하여 고급 언어차원에서 제공해주는 모니터가 생겨났다.
- 공유 데이터를 사용할 때 해당 데이터를 모니터안에서 사용하면 프로그래머는 따로 관리할 필요가 없고 모니터가 알아서 동기화 문제를 해결해주는 기법이다.
- 자바에서는 syncronized블럭안에서 작업을 수행하면 모니터가 관리해준다.알

##### 추상 자료형이란?
- 해당 자료들이 어떻게 구현되어있는지에 대해서는 알지않고 자료들과 자료들에 대한 연산이 명시되어 있는 것

### 데드락(교착 상태)?
- 일련의 프로세스, 쓰레드들이 서로가 가진 자원을 기다리며 블록된 상태

### 데드락의 발생 조건?
- 데드락의 발생조건은 **Mutual Exclution, No Preemption, Hold and Wait, Circular Wait이 있다.**
- **Mutual Exclution은** 매 순간 하나의 프로세스만이 그 자원을 사용할 수 있는 조건
- **No Preemption은** 프로세스는 스스로 자원을 내놓을 뿐 강제로 뺏기지 않는다는 조건
- **Hold and Wait은** 자원을 가진 프로세스는 자신의 자원을 내어놓지 않고 가지고 있는것
- **Circular Wait이란** 자원을 기다리는 프로세스들간에 사이클이 형성되어야 한다는 것

### 데드락 해결방법?
- 데드락을 해결하는 방법은 **DeadLock Prevetion, DeadLock Avoidance, DeadLock Detection and Recovery, DeadLock Ingorance가 있다.**
- **DeadLock Prevention은** 데드락 발생조건 중 하나를 깨뜨려 데드락을 해결하는 방법
- **DeadLock Avoidance는** 자원 요청시 부가적인 정보를 통해 데드락이 발생할 가능성이 있다면 자원을 할당해주지 않는 방식
- **DeadLock Detection and Recovery는** 데드락 발생을 허용하나 발생 시 프로세스 자원을 빼앗거나, 죽여서 데드락을 풀어내는 기법
- **DeadLock Ignorance는** 자주 발생하지 않는 데드락을 해결하기위해 운영체제가 끼어드는거 자체가 오버헤드의 원인이므로  데드락에 대해 운영체제는 아무것도 관여하지 않고 사용자가 해결하는 기법으로 범용 운영체제에서 주로 사용하는 기법이다.


### 메모리 게층 구조?
- 메모리 계층구조는 접근 속도순으로 레지스터, 캐시 메모리, 메인 메모리, 하드 디스크 등으로 구성되어 있다.
- 접근 속도가 빠른 메모리일 수록 크기 비례 가격이 비싸므로 이러한 계층 구조를 두고 중간중간 캐시를 활용하여 메모리간 병목현상을 줄인다.

### 캐시?
- 캐시란 자주 사용될만한 데이터를 미리 복사하여 저장해놓은 저장소이다.
- 캐시는 보통 **시간지역성과 공간지역성을** 활용하여 적중률을 높인다.
- 캐시의 적중률이 높을 수록 데이터 접근시간이 짧아지므로 컴퓨터의 속도를 빨라질 것이다.
- **공간적 지역성이란** 해당 데이터의 인전합 데이터들에 대한것
- **시간적 지역성이란** 가까운 시간내에 똑같은 데이터가 접근되는것

### 내부 단편화(조각), 외부 단편화(조각)
- 내부 단편화란 프로그램에 할당된 메모리이지만 크기가 맞지 않아 사용되지 않은 것
- 외부 단편화란 분할된 메모리 크기가 맞지않아 해당 메모리가 사용되지 않는 것

### 메모리 관리전략에 대해 말해주세요.
- 메모리 관리전략으로는 대표적으로 스와핑과 동적링킹이 존재한다.
- **스와핑이란** 메모리 공간이 부족할 때 프로세스를 일시적으로 스왑영역을 쫒아내고 다시 사용될때 메모리에 올리는 방식
- **동적링킹이란** 프로그램 실행시 라이브러리를 참조하는 방식으로 여러 프로그램이 한 라이브러리를 참조해서 사용하므로 라이브러리 코드를 실행 파일에 포함시키는 정적할당에 비해 메모리를 효율적으로 사용할 수 있다.

### 가상메모리(논리적 메모리)?
- 한정된 물리 메모리의 자원의 한계를 극복하고자 저장 장치를 통해 프로그램이 더 많은 메모리를 사용할 수 있도록 해주는 기법
- 보통 가상메모리로 쓰이는 저장 장치의 영역을 **스왑 영역이라고 부른다.**
- 범용 운영체제는 **페이지 기법으로 프로세스를 분할하고** 필요한 페이지만 물리적 메모리에 올리는 기법을 사용한다.
- **가상메모리는 프로세스마다 독립적으로 가지고 있다.**

### 주소 바인딩, 주소 바인딩 방법?
- **주소 바인딩이란** 가상 메모리 주소를 물리적 메모리 주소로 바인딩하는 작업이다.
- 주소 바인딩은 크게 **Compile Time, Load Time, Run Time 바인딩이 존재**
- **컴파일타임 바인딩은** 물리적 메모리주소가 컴파일시 정해지는 기법으로 범용 운영체제에서는 커널이 물리적 메모리 주소의 앞단을 차지하고 있어 구현할 수 없다.
- **로드타임 바인딩은** 프로그램 시작시점에 물리적 주소를 정한 후 그 주소는 변경될 수 없는 것으로 스왑영역을 쫒겨난후 다시 물리 메모리에 올려질 때 똑같은 메모리 주소를 가진 다른 프로세스가 있다면 사용이 불가능하므로 효율이 좋지 않습니다.
- **런타임 바인딩은** 프로그램 시작 시점에 물리적 주소를 매기는것은 로드타임바인딩과 같으나 그 주소가 상황에 따라 변경될 수 있다.
